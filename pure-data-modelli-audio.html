<!doctype html>
<html>

<head>

  <title>
    
      Pure Data e i modelli audio | ing. Andrea Maglie
    
  </title>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="utf-8">
  
  

  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="stylesheet" href="/assets/css/syntax.css">
  <!-- Use Atom -->
  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="ing. Andrea Maglie" />
  <!-- Use RSS-2.0 -->
  <!--<link href="/rss-feed.xml" type="application/rss+xml" rel="alternate" title="ing. Andrea Maglie | "/>
  //-->

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Quattrocento+Sans">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>

  <!-- Google Analytics -->
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48681711-2', 'auto');
  ga('send', 'pageview');
</script>


  <!-- Use Jekyll SEO plugin -->
  <!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Pure Data e i modelli audio | ing. Andrea Maglie</title>
<meta property="og:title" content="Pure Data e i modelli audio" />
<meta name="author" content="Andrea Maglie" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Disclaimer: Il contenuto di questo post è un estratto della mia tesi di laurea, realizzata nel 2006. Alcuni esempi potrebbero risultare obsoleti, tuttavia la componente teorica resta un buon riferimento per chi deve approcciarsi alla materia." />
<meta property="og:description" content="Disclaimer: Il contenuto di questo post è un estratto della mia tesi di laurea, realizzata nel 2006. Alcuni esempi potrebbero risultare obsoleti, tuttavia la componente teorica resta un buon riferimento per chi deve approcciarsi alla materia." />
<meta property="og:site_name" content="ing. Andrea Maglie" />
<meta property="og:image" content="/patchsliding1.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-29T00:00:00+01:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/pure-data-modelli-audio.html"},"url":"/pure-data-modelli-audio.html","publisher":null,"name":null,"author":{"@type":"Person","name":"Andrea Maglie"},"description":"Disclaimer: Il contenuto di questo post è un estratto della mia tesi di laurea, realizzata nel 2006. Alcuni esempi potrebbero risultare obsoleti, tuttavia la componente teorica resta un buon riferimento per chi deve approcciarsi alla materia.","headline":"Pure Data e i modelli audio","dateModified":"2019-01-29T00:00:00+01:00","datePublished":"2019-01-29T00:00:00+01:00","sameAs":null,"image":"/patchsliding1.jpg","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


</head>


<body>

  <div class="container">
    <header class="masthead">
  <h3 class="masthead-title">
    <a href="/">ing. Andrea Maglie</a>
    <small class="masthead-subtitle"></small>
    <div class="menu">
  <nav class="menu-content">
    
      <a href="/menu/about.html">Informazioni</a>
    
      <a href="/menu/writing.html">Post</a>
    
      <a href="/menu/contact.html">Contatti</a>
    
  </nav>
  <nav class="social-icons">
    
  
  
    <a href="https://www.github.com/techisfun" target="_blank"><i class="fa fa-github" aria-hidden="true"></i></a>
  

  
  
    <a href="https://twitter.com/techisfun" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
  

  
  
    <a href="http://www.linkedin.com/in/andreamaglie/" target="_blank"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
  

  
  
    <a href="mailto:l.andrea.maglie@gmail.com" target="_blank"><i class="fa fa-envelope" aria-hidden="true"></i></a>
  

  
  
    <a href="/feed.xml"><i class="fa fa-rss-square" aria-hidden="true"></i></a>
  

  </nav>
</div>

  </h3>
</header>


    <div class="post-container">
      <h1>
  Pure Data e i modelli audio
</h1>


  <img src="/assets/img/patchsliding1.jpg">


<hr />

<p><i>Disclaimer: Il contenuto di questo post è un estratto della mia tesi di laurea, realizzata nel 2006. Alcuni esempi potrebbero risultare obsoleti, tuttavia la componente teorica resta un buon riferimento per chi deve approcciarsi alla materia.</i></p>
<hr />

<h2 id="il-modello-di-rotolamento">Il modello di rotolamento</h2>

<p>Tra le comuni interazioni meccaniche che coinvolgono oggetti solidi, il
rotolamento forma una categoria interessante anche dal punto di vista
dell’audio: l’esperienza di tutti i giorni ci dice che il suono prodotto
da un oggetto rotolante viene spesso riconosciuto come tale, e in
generale è distinto da altri suoni come quelli dovuti allo sfregamento
anche degli stessi oggetti. Ciò potrebbe essere dovuto alla natura del
rotolamento come un processo di interazione continua, dove la forza
mutua sugli oggetti coinvolti è descritta come un impatto senza
l’aggiunta di forze di frizione perpendicolari. Oltre ad essere
caratteristici, i suoni di rotolamento portano importanti informazioni:
in aggiunta alle caratteristiche di risonanza degli oggetti coinvolti
(che dipendono da forma, dimensione e materiale), altri attributi
vengono espressi nel suono, attributi <em>di trasformazione</em>, come
velocità, gravità o accelerazione/decelerazione. Lo sviluppo di un
modello di rotolamento espressivo e in tempo reale da presupposti
fisici, acustici e implementativi è descritto di seguito.</p>

<h3 id="linterazione-di-rotolamento-con-il-modello-di-impatto-come-blocco-di-base">L’interazione di rotolamento con il modello di impatto come blocco di base</h3>

<figure class="image">
  <img src="images/rolling1.jpg" alt="Figura 1: Tracciato del movimento di una palla che segue un profilo di
superficie s(x). Non si tratta del moto reale ma di una idealizzazione utile per ricavare la curva usata dal modello di impatto" />
  <figcaption>Figura 1: Tracciato del movimento di una palla che segue un profilo di
superficie s(x). Non si tratta del moto reale ma di una idealizzazione utile per ricavare la curva usata dal modello di impatto</figcaption>
</figure>

<p>Contrariamente ad azioni quali lo sfregare o il grattare, la forza di
interazione dei due oggetti coinvolta in un semplice scenario di
rotolamento (l’oggetto rotolante e il piano) è perpendicolare alla
superficie di contatto (la curva media macroscopica), diretta lungo la
linea che connette il punto di contatto e il centro di gravità
dell’oggetto rotolante. Le condizioni di contatto devono essere
modificate per riflettere le varie distanze della superficie di contatto.
L’oggetto rotolante è assunto come localmente sferico, senza dettagli
macroscopici sulla superficie. E’ possibile fare queste assunzioni dal
momento che i dettagli microscopici della superficie dell’oggetto
rotolante possono essere semplicemente aggiunti alla superficie sulla
quale l’oggetto rotola, e può essere variato il raggio di curvatura
della superficie stessa; vedremo che anche l’assumere un raggio costante
può essere soddisfacente per la maggior parte degli scopi. E’ importante
notare che il contatto tra i due oggetti durante il rotolamento è
ristretto a punti distinti: il piano non viene seguito nella sua
interezza.</p>

<p>Il movimento reale dell’oggetto rotolante si differenzia da questa
idealizzazione a causa dell’elasticità e dell’inerzia. In buona
approssimazione, il movimento verticale del centro della palla è
calcolato con un modello di impatto unidimensionale con la curva in figura 1. I
punti di contatto e la traiettoria risultante, che idealmente dovrebbe
essere applicata al modello di impatto unidimensionale, sono
rappresentati in figura 2. Il calcolo esatto dei punti di contatto è
dispendioso in termini di risorse computazionali: in ogni punto <script type="math/tex">x</script>
lungo la curva della superficie, cioè per ogni punto di campionamento
nel caso discreto (dove la frequenza del campionamento è la stessa del
campionamento audio), deve essere calcolata la seguente funzione che
descrive l’attuale punto <script type="math/tex">p_x</script> :</p>

<script type="math/tex; mode=display">f_x(p_x) \stackrel{!}{=} max_{q\in[x-r,x+r]}f_x(q) \hspace{0,5cm}, \label{eq:rolling1}</script>

<p>dove</p>

<script type="math/tex; mode=display">f_x(q) = s(q) + \sqrt{r^2 - (q-x)^2} \hspace{0,5cm},\hspace{0,5cm} q \in [x-r, x+r] \hspace{0,5cm}. \label{eq:rolling2}</script>

<p>La curva ideale viene poi calcolata da questi punti di contatto. Una tecnica più semplice (e quindi anche meno dispendiosa in termini di risorse di calcolo) è rappresentata in figura 3.
La traiettoria in figura 2 converge alla curva ideale di figura 3 per raggi molto grandi se comparati alla ruvidità della superficie. 
Infatti, in una prima implementazione, anche le forti semplificazioni (riportate figura 4 realizzate con un algoritmo molto semplice, hanno dato risultati
convincenti.</p>

<figure class="image">
  <img src="images/rolling2.jpg" alt="Figura 2: Tracciato della curva di offset effettiva risultante dalla superficie s(x)." />
  <figcaption>Figura 2: Tracciato della curva di offset effettiva risultante dalla superficie s(x).</figcaption>
</figure>

<figure class="image">
  <img src="images/rolling3.jpg" alt="Figura 3: Approssimazione del tracciato compiuto dalla palla durante il rotolamento." />
  <figcaption>Figura 3: Approssimazione del tracciato compiuto dalla palla durante il rotolamento.</figcaption>
</figure>

<figure class="image">
  <img src="images/rolling4.jpg" alt="Figura 4: Ulteriore approssimazione del tracciato di rotolamento." />
  <figcaption>Figura 4: Ulteriore approssimazione del tracciato di rotolamento.</figcaption>
</figure>

<h3 id="sec:superficie">La superficie</h3>

<p>Esistono diverse tecniche per realizzare il profilo della superficie
alla base del modello di rotolamento. Una possibilità è quella di
campionare o effettuare una scansione di superfici reali e usare tali
segnali come input per lo stadio seguente del modello; questo approccio
però non si adatta ai nostri obiettivi: noi siamo interessati ad un
modello parametrico, flessibile ed efficiente piuttosto che ad una
singola simulazione realistica. Inoltre i segnali memorizzati sono
difficili da adattare alle variazioni degli attributi del modello;
preferiamo quindi usare modelli statistici di superfici che possano
efficientemente generare segnali per i vari attributi.</p>

<p>E’ comune nella computer graphics descrivere le superfici tramite metodi
frattali. L’applicazione di questa idea al nostro modello
unidimensionale conduce all’utilizzo di un segnale di rumore con spettro
di potenza <script type="math/tex">1/f^{\beta}</script>, o equivalentemente rumore bianco filtrato con
queste caratteristiche. Il parametro reale <script type="math/tex">\beta</script> riflette la
dimensione frattale (o ruvidità). I risultati pratici di questo tipo di
modello sono diventati più convincenti quando la banda del segnale della
superficie è stata fortemente limitata; ciò non deve sorprendere se
pensiamo che solitamente le superfici coinvolte nel rotolamento sono
molto smussate. Smussare su larga scala (che può essere assimilato al
tagliare pezzi di pietra per pavimentazioni) corrisponde ad un
filtraggio passa–alto, mentre smussare a livello microscopico (come
lucidare una pietra) può essere visto come un filtraggio di tipo
passa–basso. Tramite queste elaborazioni però si possono perdere le
caratteristiche del rumore <script type="math/tex">1/f^{\beta}</script> di partenza. Perciò optiamo per
una approssimazione di questa curva con un filtro del secondo ordine la
cui ripidità è proporzionale al grado di ruvidità a livello
microscopico.</p>

<p>Tutte le frequenze in questo modello di basso livello devono variare
proporzionalmente ai parametri di velocità, perciò l’ampiezza del
segnale di superficie deve essere mantenuta costante. Naturalmente i
parametri dell’impatto, in particolare la costante di elasticità <script type="math/tex">k</script>,
devono essere variati opportunamente a seconda della superficie che si
vuole simulare (cioè in base alle proprietà del materiale), in quanto
contribuiscono fortemente alla espressività del modello.</p>

<h3 id="il-modello-di-impatto">Il modello di impatto</h3>

<p>Un suono di contatto è descritto tramite due sistemi, uno per l’oggetto
risonante e uno per l’oggetto percussore. Supposto che la superficie di
contatto sia piccola, la forza di contatto viene espressa come:</p>

<script type="math/tex; mode=display">% <![CDATA[
f(x(t),v(t)) = \left\{
                                            \begin{array}{ll}
                                            kx(t)^{\alpha}+\lambda x(t)^{\alpha}\cdot v(t) = kx(t)^{\alpha}(1+\mu v(t)) & x > 0\\
                                            0 & x \leq 0
                                            \end{array}
                                \right.
\hspace{0,5cm}, \label{eq:impact1} %]]></script>

<p>dove <script type="math/tex">v(t) = \dot{x}(t)</script> è la velocità di compressione, <script type="math/tex">k</script> è il
coefficiente di rigidità, <script type="math/tex">\alpha</script> è un parametro che descrive la
geometria locale dell’impatto (nel caso di due perfette sfere vale 1.5),
<script type="math/tex">\lambda</script> è un coefficiente di smorzamento e <script type="math/tex">\mu = \lambda/k</script> è un
termine matematico (senza significato fisico) detto <em>caratteristica
viscoelastica</em>.</p>

<p>Il percussore è considerato una massa ideale, quindi l’unico parametro
che lo caratterizza è la massa; il risonatore invece è un oggetto modale
ed è caratterizzato dai parametri di frequenza, tempi di decadimento,
<script type="math/tex">k</script>, <script type="math/tex">\alpha</script> e <script type="math/tex">\lambda</script>. Si assume inoltre che il percussore abbia un
elevato coefficiente di smorzamento: in tal modo diventa trascurabile
l’energia acustica delle sue vibrazioni, e l’energia viene trasferita al
risonatore che emette il suono. Per una descrizione matematica vengono
sintetizzati i modi di vibrazione (teoricamente infiniti), ognuno dei
quali fornisce un contributo allo spettro del segnale <a class="citation" href="#art:soundobj">(Avanzini, F., Rath, M., &amp; Rocchesso, D., 2003)</a>.</p>

<h3 id="caratteristiche-di-alto-livello">Caratteristiche di alto livello</h3>

<p>Oltre ai parametri di basso livello visti nella sezione precedente, i
tipici moti di rotolamento posseggono caratteristiche a livello
macroscopico che contribuiscono fortemente alla percezione acustica, e
non possono essere descritti come fatto in precedenza. Molte superfici
contengono dei pattern più o meno regolari che non possono essere
classificati come rumore frattale filtrato, e tali periodicità possono
essere verificate attraverso l’esperienza di tutti i giorni: i pavimenti
in pietra, o i solchi pseudoperiodici in molte tavole di legno. Le
singole irregolarità sulla superficie dell’oggetto rotolante possono
essere raggruppate in una sola categoria, dal momento che sono
richiamate periodicamente nel movimento rotatorio. Tale caratteristica
può essere modellata con segnali impulsivi di frequenza costante o
variante in un piccolo intervallo; potrebbero essere utili delle
approssimazioni sinusoidali o polinomiali, con un parametro di
smussamento legato al grado di approssimazione della funzione. Ancora,
le frequenze devono variare proporzionalmente alla velocità.</p>

<p>Dev’essere fatta un’altra osservazione a livello macroscopico: per
oggetti rotolanti che non sono perfettamente sferici (in maniera
rilevante per il movimento) la velocità del punto di contatto su
entrambe le superfici e l’effettiva forza che preme l’oggetto rotolante
sulla superficie variano periodicamente; devono essere variati questi
due parametri per modellare tale deviazione dalla sfericità perfetta.</p>

<p>Infine notiamo che, come nell’ascolto di tutti i giorni, gli scenari
acustici del rotolamento di oggetti sono riconosciuti e accettati più
facilmente se sono presenti dinamiche tipiche; ad esempio pensiamo al
suono di una palla che cade e che rimbalza fino a quando non raggiunge
un contatto costante con il suolo: a questo punto il rotolamento diventa
chiaro dal punto di vista uditivo e la velocità media lentamente
diminuisce fino diventare nulla.</p>

<h2 id="sec:tessiture_superficie">Tessiture della superficie</h2>

<p>Molti dei suoni di contatto ai quali siamo interessati non possono
essere ricreati in modo convincente usando solo modelli deterministici,
come nel caso dei suoni di rotolamento risultanti dalla sequenza di
micro impatti tra due oggetti risonanti, determinati dal profilo della
superficie di contatto. Affrontiamo quindi il problema di effettuare il
rendering delle tessiture di superfici attraverso processi frattali;
tali processi sono molto usati nella computer graphics, dal momento che
forniscono tessiture che sembrano naturali all’occhio umano. Dato che
nei modelli fisici le proprietà delle superfici vengono tradotte
direttamente in segnali di forza e, di conseguenza, in suoni, sembra
naturale seguire lo stesso approccio per modellare le superfici.</p>

<p>I frattali sono definiti <a class="citation" href="#book:fractal">(Hastings, H. M. &amp; Sugihara, G., 1993)</a> come geometrie invarianti
rispetto alla scalatura. Sono auto–simili se la scalatura è isotropica
o uniforme in tutte le direzioni, auto–affini se la scalatura è
anisotropica o dipendente dalla direzione, staticamente auto–simili se
sono l’unione di copie di se stessi scalate statisticamente. Più
formalmente, un processo frattale unidimensionale può essere definito
come una generalizzazione della definizione di moto standard Browniano
<a class="citation" href="#book:brownian">(Resnick, S., 1992)</a>.</p>

<p>Il processo stocastico <script type="math/tex">x = \{x(t),t \geq 0\}</script> è un moto standard Browniano se:</p>

<ol>
  <li>il processo stocastico <script type="math/tex">x</script> ha incrementi indipendenti;</li>
  <li>vale la proprietà
<script type="math/tex">% <![CDATA[
x(t) - x(s) \sim N(0,t-s) \hspace{0,5cm} per \hspace{0,5cm} 0 \leq s < t; %]]></script>
cioè l’incremento <script type="math/tex">x(t) - x(s)</script> è normalmente distribuito con media
nulla e varianza <script type="math/tex">(t-s)</script>;</li>
  <li>è vero che <script type="math/tex">x(0) = 0.</script></li>
</ol>

<p>La definizione di moto standard Browniano può essere generalizzata alla
definizione di <em>processo frattale</em> se l’incremento <script type="math/tex">x(t)-x(s)</script> è
normalmente distribuito con media 0 e varianza proporzionale a
<script type="math/tex">(t-s)^{2H}</script>. Il parametro <em>H</em> è chiamato <em>esponente di Hurst</em> e
caratterizza il comportamento del processo frattale rispetto alla
scalatura: se <script type="math/tex">x=\{x(t),t \geq 0\}</script> è un processo frattale con esponente
di Hurst <script type="math/tex">H</script>, allora, per ogni reale <script type="math/tex">a > 0</script>, obbedisce alla seguente
relazione di scala:</p>

<script type="math/tex; mode=display">x(t) \stackrel{P}{=} a^{-H}x(at) \hspace{0,5cm} , \label{eq:surface1}</script>

<p>dove <script type="math/tex">\stackrel{P}{=}</script> denota l’uguaglianza statistica. Questa è la
definizione formale di <em>auto–similirarità statistica</em>. La famiglia di
processi <script type="math/tex">1/f</script> statisticamente auto–simili, nota anche come rumore <script type="math/tex">1/f</script>, è
composta da processi aventi densità di spettro di potenza <script type="math/tex">S_x(\omega)</script>
proporzionale a <script type="math/tex">1/ \omega^{\beta}</script>, con <script type="math/tex">\beta</script> legato all’esponente di
Hurst <script type="math/tex">H</script> dalla relazione <script type="math/tex">\beta = 2H + 1</script>. Per <script type="math/tex">\beta = 0</script> la
definizione corrisponde al rumore bianco, per <script type="math/tex">\beta = 2</script> si ottiene il
rumore Browniano, e per <script type="math/tex">\beta = 1</script> il rumore risultante è rumore rosa.
Il parametro <script type="math/tex">\beta</script> è in relazione anche con la dimensione frattale. La
dimensione frattale <a class="citation" href="#book:wornell">(Wornell, G. W., 1998)</a> di una funzione è un parametro reale
che determina l’irregolarità di un oggetto frattale, è legata al grafico
della funzione ed è usata nella computer graphics per controllare la
ruvidità percepita <a class="citation" href="#art:pentland">(Pentland, A. P., 1988)</a>. Per i processi <script type="math/tex">1/f</script>, tale dimensione
è inversamente proporzionale all’esponente di Hurst <script type="math/tex">H</script>: valori maggiori
di <script type="math/tex">H</script> corrispondono a valori minori della dimensione frattale; <script type="math/tex">H</script> è
proporzionale a <script type="math/tex">\beta</script>. Perciò, incrementando <script type="math/tex">\beta</script> possiamo
raggiungere una redistribuzione della potenza dalle alte alle basse
frequenze, con uno smussamento complessivo della forma d’onda.</p>

<p>Il problema di generare il rumore <script type="math/tex">1/f</script> è stato trattato estensivamente.
Uno degli approcci più comuni risulta quello di filtrare una sorgente di
rumore bianco per ottenere lo spettro <script type="math/tex">1/f</script>; seguendo questo procedimento
utilizzeremo il modello riportato in <a class="citation" href="#art:saletti">(Saletti, R., Novembre 1986)</a> e <a class="citation" href="#art:corsini">(Corsini, G. &amp; Saletti, R., Dicembre 1988)</a>. Il
filtro è una cascata di N filtri del primo ordine, ognuno con una coppia
di poli e zeri; la funzione di trasferimento <script type="math/tex">H(s)</script> nel dominio di
Laplace è la seguente:</p>

<script type="math/tex; mode=display">H(s)=A\frac{\prod_{i=1}^{N}(s-s_{0i})}{\prod_{i=1}^{N}(s-s_{pi})} \hspace{0,5cm} ,  \label{eq:surface2}</script>

<p>dove <script type="math/tex">A</script> è una costante. Il generatore di rumore frattale è ottenuto
impostando opportunamente i poli e gli zeri dei filtri nella cascata
<a class="citation" href="#art:saletti">(Saletti, R., Novembre 1986)</a>. In particolare, il polo e lo zero alle frequenze
<script type="math/tex">f_{pi}</script> e <script type="math/tex">f_{0i}</script> possono essere computati come funzioni di <script type="math/tex">\beta</script>
con le seguenti formule:</p>

<script type="math/tex; mode=display">f_{pi} = -\frac{s_{pi}}{2\pi} = f_{p(i-1)}10^{\frac{1}{h}} \hspace{0,5cm} , \label{eq:surface3a}</script>

<script type="math/tex; mode=display">f_{0i} = - \frac{s_{0i}}{2\pi} = f_{pi}10^{\frac{\beta}{2h}} \hspace{0,5cm} , \label{eq:surface3b}</script>

<p>dove <script type="math/tex">f_{p1}</script> è il polo di frequenza più bassa del filtro; perciò il
limite inferiore della banda di frequenza per l’approssimazione è
<script type="math/tex">f_{p1}</script>. La densità <script type="math/tex">h</script> (densità dei poli per decade di frequenze) può
essere usata per controllare l’errore tra lo spettro desiderato e lo
spettro approssimato ottenuto dal filtraggio del rumore bianco. La
dipendenza dell’errore in relazione alla densità dei poli del filtro è
discussa in <a class="citation" href="#art:corsini">(Corsini, G. &amp; Saletti, R., Dicembre 1988)</a>. La figura mostra uno spettro <script type="math/tex">1/f^{\beta}</script> ottenuto usando
il filtro <script type="math/tex">f_{pi}</script>, con due diversi valori per <script type="math/tex">h</script>.</p>

<figure class="image">
  <img src="images/noise.jpg" alt="Spettro di ampiezza del rumore frattale generato con $$\beta=1.81$$, $$h=2$$ a sinistra e $$h=6$$ a destra." />
  <figcaption>Spettro di ampiezza del rumore frattale generato con $$\beta=1.81$$, $$h=2$$ a sinistra e $$h=6$$ a destra.</figcaption>
</figure>

<p>La funzione di trasferimento nel dominio discreto del tempo può essere
computata con il metodo della varianza della risposta all’impulso
 <a class="citation" href="#book:mitra">(Mitra, S. K., 1998)</a>; ciò corrisponde a mappare poli e zeri della funzione di
trasferimento <script type="math/tex">H(s)</script> su poli e zeri della funzione di trasferimento
<script type="math/tex">H(z)</script> nel dominio discreto del tempo attraverso la seguente
sostituzione:</p>

<script type="math/tex; mode=display">s-s_x \rightarrow 1-e^{s_xT_s}z^{-1} \hspace{0,5cm} , \label{eq:surface4}</script>

<p>dove <script type="math/tex">T_s</script> è il periodo di campionamento e <script type="math/tex">s_x</script> indica un polo <script type="math/tex">s_{pi}</script>
o uno zero <script type="math/tex">s_{0i}</script>. Si ottiene la seguente funzione di trasferimento
discreta:</p>

<script type="math/tex; mode=display">H(z)=A' \frac { \prod^{N}_{i=1}1-e^{s_{0i}T}z^{-1} }{ \prod^{N}_{i=1}1-e^{s_{pi}T}z^{-1} } \hspace{0,5cm} , \label{eq:surface5}</script>

<p>dove <script type="math/tex">A'</script> è una costante di normalizzazione. In conclusione, lo spettro
<script type="math/tex">1/f^{\beta}</script> è approssimato da una cascata di filtri del primo ordine,
ognuno con la seguente funzione di trasferimento discreta:</p>

<script type="math/tex; mode=display">% <![CDATA[
H^{(i)}(z)=\frac{1+b_iz^{-1}}{1+a_iz^{-1}} \hspace{0,5cm} , \hspace{0,5cm} con \hspace{0,5cm}
 \left\{
 \begin{array}{ll}
 a_i=e^{-2{\pi}f_{pi}T}, & b_i=e^{-2{\pi}f_{0i}T} \\
 \\
 f_{pi}=f_{p(i-1)}10^{\frac{1}{h}}, & f_{0i}=f_{pi}10^{\frac{\beta}{2h}} \\
 \end{array}
 %\hspace{0,5cm}
 \right .
 \label{eq:surface6} %]]></script>

<hr />

<h2 id="implementazioni-dei-modelli-in-pure-data">Implementazioni dei modelli in Pure Data</h2>

<h3 id="cosè-pure-data">Cos’è Pure Data</h3>

<figure class="image">
  <img src="images/pd1_bn.jpg" alt="L'interfaccia grafica di Pure Data" />
  <figcaption>L'interfaccia grafica di Pure Data</figcaption>
</figure>

<p>Pure Data è un software ideato da Miller Puckette: si tratta di un
ambiente di programmazione visuale in real–time per l’elaborazione di
audio e grafica, basato sul sistema <em>Max/MSP</em> ma più semplice e
portabile di questo. Sono presenti due caratteristiche in PD molto
importanti: la possibilità di gestire contemporaneamente la simulazione
video e la simulazione audio utilizzando il pacchetto <em>GEM</em> di Mark Dank
e delle facilitazioni nelle definizioni nell’accesso alle strutture
dati.</p>

<p>Ogni documento di PD è chiamato <em>patch</em>; una volta che tale file viene
aperto si presenta composto di una finestra principale e di eventuali
sotto–finestre (che possono essere visualizzate o nascoste ma sono
sempre in esecuzione). In ogni finestra compaiono dei blocchi collegati
tra loro; i blocchi possono essere di quattro tipi:</p>

<h4 id="oggetti">Oggetti</h4>
<p>Un oggetto viene creato scrivendo del testo all’interno del blocco;
il testo viene diviso in <em>atomi</em>: il primo atomo definisce il tipo
di oggetto che viene creato, i successivi costituiscono gli
argomenti di creazione, i quali servono ad inizializzare l’oggetto.</p>

<p>Ogni oggetto può possedere zero o più <em>inlet</em> (collegamenti in
input) e zero o più <em>outlet</em> (collegamenti in output); il numero di
questi dipende dal tipo di oggetto. Ci sono due tipi di
collegamento: <em>collegamenti di segnale</em> e <em>collegamenti di
controllo</em>; i primi sono rappresentati da una linea marcata, mentre
i secondi da una linea sottile. La scelta del tipo di collegamento
dipende dall’outlet dal quale provengono; un outlet può essere
collegato ad un inlet solo se entrambi accettano collegamenti dello
stesso tipo (o entrambi di segnale o entrambi di controllo).</p>

<p>In figura è riportato un esempio di oggetto: l’atomo 1+1 definisce
la tipologia di oggetto (un blocco sommatore), mentre il secondo
atomo 13 indica il valore da sommare all’ingresso.</p>

<figure class="image">
  <img src="images/obj1.jpg" alt="" />
  <figcaption></figcaption>
</figure>

<h4 id="messaggi">Messaggi</h4>
<p>I blocchi di messaggio interpretano il testo come un messaggio da
inviare ogni volta che il blocco viene attivato; l’invio è verso il
blocco al quale l’outlet è collegato e può avvenire un numero
qualsiasi di volte durante l’esecuzione della patch. Il blocco di
messaggio possiede sempre un inlet e un outlet. Nell’esempio
seguente il primo blocco, quando viene attivato dal click del mouse,
invia il messaggio 21 all’oggetto che lo sommerà a 13 all’ultimo
blocco viene inviato il risultato dell’operazione.</p>

<figure class="image">
  <img src="images/mess1.jpg" alt="Semplice esempio di patch per Pure Data." />
  <figcaption>Semplice esempio di patch per Pure Data.</figcaption>
</figure>

<p>Un messaggio può essere attivato cliccandoci sopra, da un altro
messaggio in ingresso o da un particolare blocco chiamato <em>bang</em>.</p>

<h4 id="gui">GUI</h4>
<p>Il terzo blocco dell’esempio precedente fa parte dei blocchi GUI
(graphical user interface); tra questi sono inclusi i blocchi
numerici, blocchi contenenti simboli, controlli scorrevoli e
pulsanti. Mentre gli oggetti rimangono immutati durante l’esecuzione
di una patch, i blocchi GUI aggiornano il loro stato in base al
valore che contengono.</p>

<h4 id="commenti">Commenti</h4>

<p>I commenti sono costituiti da semplice testo e non sono contenuti
all’interno di nessun rettangolo. Nella figura precedente i
testi alla destra dei blocchi sono commenti.</p>

<p>Una patch può essere in modalità <em>edit</em> oppure in modalità <em>running</em>:
nel primo caso la patch non è in esecuzione ed è permessa la creazione o
modifica dei blocchi e dei collegamenti; nel secondo caso la patch è in
esecuzione, è possibile ancora modificare i collegamenti, mentre la
modifica dei blocchi GUI ha l’effetto di variare i parametri di
controllo della patch.</p>

<h3 id="lincapsulamento-in-pure-data">L’incapsulamento in Pure Data</h3>

<p>Come avviene con i linguaggi di programmazione quali C, C++ e Java, con
Pure Data è possibile scrivere del codice che può poi essere
riutilizzato in qualsiasi momento; uno o più oggetti infatti possono
essere costituiti da <em>subpatch</em>, ovvero delle patch separate che vengono
incapsulate all’interno dell’oggetto. Si possono distinguere due tipi di
incapsulamento:</p>

<ul>
  <li>
    <p>one–off subpatch – se l’oggetto viene chiamato <code class="highlighter-rouge">pd</code> o <code class="highlighter-rouge">pd my-name</code>, viene creata una subpatch il cui contenuto viene salvato come parte della patch genitore che può essere riutilizzata e modificata più volte all’interno di quest’ultima;</p>
  </li>
  <li>
    <p>astrazione – se l’oggetto ha il nome di una patch già presente come file (omettendo l’estensione <code class="highlighter-rouge">.pd</code>), PD caricherà il contenuto del file all’interno della subpatch; in tal caso un cambiamento alla patch si propaga a tutte le chiamate alla sua astrazione.</p>
  </li>
</ul>

<p>Per definire il numero di inlet e outlet che deve possedere l’oggetto
contenente la subpatch è sufficiente utilizzare all’interno di
quest’ultima i blocchi <code class="highlighter-rouge">inlet</code> e <code class="highlighter-rouge">outlet</code> (oppure <code class="highlighter-rouge">inlet~</code> e <code class="highlighter-rouge">outlet~</code>
per i collegamenti di segnale).</p>

<h3 id="gestione-dei-segnali-audio">Gestione dei segnali audio</h3>

<figure class="image">
  <img src="images/logicaltime.jpg" alt="Linee del tempo per la computazione audio e la computazione di controllo in Pure Data con (a) blocchi di un campione e (b) blocchi di quattro campioni." />
  <figcaption>Linee del tempo per la computazione audio e la computazione di controllo in Pure Data con (a) blocchi di un campione e (b) blocchi di quattro campioni.</figcaption>
</figure>

<p>In Pure Data i segnali audio vengono memorizzati come numeri in virgola
mobile a 32 bit; a seconda dell’hardware utilizzato però l’output viene
limitato a 16 o 24 bit. L’input è sempre compreso tra i valori 1 e -1,
mentre l’output viene tagliato al fine di restare compreso tra questi
due limiti. La frequenza di campionamento di default è 44100 Hz
(modificabile da riga di comando o nel menù <em>audio setup</em>).</p>

<p>Le computazioni audio vengono eseguite dai <em>blocchi tilde</em>, cioè quelli
che, per convenzione, hanno il nome seguito da una tilde, come <code class="highlighter-rouge">sc~</code>;
essi comunicano attraverso connessioni di segnale. All’avvio della
computazione, o quando vengono cambiati i collegamenti, gli oggetti
tilde vengono ordinati secondo un ordine di esecuzione lineare; tale
lista viene poi eseguita in blocchi di 64 campioni ciascuno (a 44.1 KHz
significa che l’intera rete di blocchi audio viene eseguita una volta
ogni 1.45 millisecondi). Le connessioni nella rete audio devono essere
acicliche; la presenza di eventuali cicli viene rilevata al momento del
riordino dei blocchi. Ogni subpatch può avere dei collegamenti di
segnale in entrata e in uscita tramite i blocchi “inlet<script type="math/tex">\sim</script>” e
“outlet<script type="math/tex">\sim</script>”.</p>

<p>La computazione dei segnali non avviene in <em>real time</em>, ma in <em>logical
time</em>: quest’ultimo è definito come l’istante del successivo campione
audio che verrà elaborato, ed è sempre precedente al real time, definito
come l’istante in cui il campione arriva all’output. Tutto questo serve
a far sì che la computazione audio sia indipendente dal tempo effettivo
di esecuzione del processore, il quale può variare per molte ragioni. Si
può dedurre che una computazione audio, se eseguita nel modo corretto, è
deterministica: due esecuzioni dello stesso calcolo, una in tempo reale
e l’altra no, devono dare lo stesso risultato. In
figura si vede come la computazione dell’audio
viene svolta rispetto all’elaborazione dei segnali di controllo: i
campioni audio vengono calcolati a scadenze regolari, ma prima di ogni
scadenza devono essere effettuati tutti i calcoli di controllo che
possono influenzare il campione audio in quella scadenza. Se <script type="math/tex">N</script> è il
numero di campioni in un blocco, la prima computazione audio riguarda i
campioni da <script type="math/tex">0</script> a <script type="math/tex">N-1</script>, i quali vengono inviati in output tutti insieme
all’istante <script type="math/tex">N</script> (logical time); prima di questo istante vengono
effettuate tutte le elaborazioni di controllo per gli <script type="math/tex">N</script> campioni.</p>

<h4 id="conversione-tra-segnali-audio-e-segnali-di-controllo">Conversione tra segnali audio e segnali di controllo</h4>

<p>La conversione da segnale di controllo a segnale audio è possibile
utilizzando l’oggetto <code class="highlighter-rouge">sig~</code>. Per quanto riguarda la conversione inversa
(da segnale a controllo) deve essere specificato l’istante nel quale il
segnale viene campionato; questo può essere gestito tramite l’oggetto
<code class="highlighter-rouge">snapshot~</code> che campiona il segnale ogni volta che riceve in input un
<em>bang</em>. Gli oggetti <code class="highlighter-rouge">+~</code>, <code class="highlighter-rouge">-~</code>, <code class="highlighter-rouge">*~</code>, <code class="highlighter-rouge">/~</code>, <code class="highlighter-rouge">osc~</code> e <code class="highlighter-rouge">phasor~</code> possono
essere configurati per accettare entrambi i tipi di segnale.</p>

<h4 id="selettori-e-blocchi">Selettori e blocchi</h4>

<p>Gli oggetti <code class="highlighter-rouge">switch~</code> e <code class="highlighter-rouge">block~</code> sono utilizzati per attivare o
disattivare parti della computazione audio e per controllare la
dimensione dei blocchi di calcolo; deve essere presente uno solo dei due
oggetti per ogni finestra della patch e il suo effetto verrà esteso a
tutte le subpatch. Entrambi accettano due argomenti per la loro
costruzione: il primo è la dimensione del blocco e il secondo un fattore
di sovrapposizione.</p>

<p>L’oggetto <code class="highlighter-rouge">switch~</code> può essere usato per ridurre il carico
computazionale scegliendo, ad esempio, uno tra diversi algoritmi di
sintesi da utilizzare: per farlo è sufficiente che ogni algoritmo sia
implementato in una subpatch diversa.</p>

<h4 id="connessioni-esterne">Connessioni esterne</h4>

<p>I segnali possono essere inviati non solo tra blocchi di una stessa
finestra, ma anche tra finestre diverse oppure possono essere dati in
input all’algoritmo che li ha generati in una configurazione in
retroazione. Questo può essere implementato attraverso tre coppie di
oggetti:</p>

<dl>
  <dt>throw<script type="math/tex">\sim</script>/catch<script type="math/tex">\sim</script> –</dt>
  <dd>
    <p><code class="highlighter-rouge">throw~</code> accumula dati in un bus, mentre <code class="highlighter-rouge">catch~</code> legge i dati
accumulati e riazzera il bus per il ciclo successivo;</p>
  </dd>
  <dt>send<script type="math/tex">\sim</script>/receive<script type="math/tex">\sim</script> –</dt>
  <dd>
    <p><code class="highlighter-rouge">send~</code> salva un segnale che può essere ricevuto più volte da un
blocco <code class="highlighter-rouge">receive~</code>, il quale però può leggere un solo <code class="highlighter-rouge">send~</code> alla
volta;</p>
  </dd>
  <dt>delread<script type="math/tex">\sim</script>/delwrite<script type="math/tex">\sim</script> –</dt>
  <dd>
    <p>se viene inviato un segnale ad un punto precedente nella rete audio,
esso viene ricevuto solo al ciclo successivo, con un ritardo quindi
di 1.45 millisecondi (con le impostazioni di default). Gli oggetti
<code class="highlighter-rouge">delread~</code> e <code class="highlighter-rouge">delwrite~</code> permettono di ridurre al minimo tale
ritardo.</p>
  </dd>
</dl>

<h4 id="scheduling">Scheduling</h4>

<p>Lo scheduler di Pure Data cerca di mantenere un certo <em>vantaggio</em> sul
calcolo in modo da poter assorbire eventuali forti incrementi nel carico
computazionale; tale comportamento può essere impostato tramite le flag
“audiobuffer” o “frags”.</p>

<p>Se durante l’elaborazione dell’audio si accumulano dei ritardi, possono
verificarsi delle interruzioni nei flussi di input e output; tuttavia lo
streaming su disco non viene influenzato.</p>

<p>Le operazioni di PD sono deterministiche, nel senso che le computazioni
vengono eseguite nel momento in cui vengono schedulate senza subire
cambiamenti di ordine in real–time. Se un’operazione viene attivata da
un evento esterno, viene associata ad un tempo; questo serve a garantire
che le esecuzioni siano consistenti con le scadenze temporali imposte
dallo scheduler (il tempo non deve mai decrescere).</p>

<h3 id="scrivere-external-per-pure-data">Scrivere <em>external</em> per Pure Data</h3>

<p>Con il termine <em>external</em> si indica un oggetto che non è compreso in
Pure Data ma che può essere caricato dinamicamente durante l’esecuzione
di PD; si differenziano dagli <em>internal</em> in quanto questi ultimi sono le
primitive già incluse in PD. Una volta che un external viene caricato in
memoria, non è più distinguibile dagli internal. Una libreria è una
collezione di external compilati all’interno di un unico file binario;
il nome di una libreria varia a seconda del sistema operativo per la
quale viene implementata: ad esempio, se viene creata la libreria
<code class="highlighter-rouge">my_lib</code>, essa dovrà essere chiamata <code class="highlighter-rouge">my_lib.pd_linux</code> nei sistemi
Linux, <code class="highlighter-rouge">my_lib.pd_irix</code> e <code class="highlighter-rouge">my_lib.dll</code> nei sistemi Win32. Una libreria
elementare include esattamente un external avente lo stesso nome della
libreria.</p>

<p>A differenza degli external, una libreria può essere importata in due
modi:</p>

<ul>
  <li>
    <p>tramite opzione da riga di comando: <code class="highlighter-rouge">-lib my_lib</code> (così la libreria e tutti gli external in essa contenuti vengono caricati all’avvio di PD);</p>
  </li>
  <li>
    <p>creando un oggetto <code class="highlighter-rouge">my_lib</code> (consigliabile quando la libreria contiene un solo oggetto con il nome della libreria stessa).</p>
  </li>
</ul>

<p>In entrambi i casi PD prima controlla se una libreria <code class="highlighter-rouge">my_lib</code> è già
stata caricata; se così non è, viene cercato il file corrispondente e,
se trovato, tutti gli external inclusi vengono caricati.</p>

<p>Pure Data è scritto in C, quindi anche gli external vanno scritti in
questo linguaggio di programmazione; il codice per un semplice external
che stampa il messaggio “hello world!” è riportato di seguito
 <a class="citation" href="#pdexternal">(Zmölnig, J. M., n.d.)</a>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #include "m_pd.h"

    static t_class *helloworld_class;

    typedef struct _helloworld {
    t_object x_obj;
    } t_helloworld;

    void helloworld_bang(t_helloworld *x)
    {
        post("Hello world !!");
    }

    void *helloworld_new(void)
    {
        t_helloworld *x = (t_helloworld *)pd_new(helloworld_class);
        return (void *)x;
    }

    void helloworld_setup(void)
    {
        helloworld_class = class_new(gensym("helloworld"),
                                                (t_newmethod)helloworld_new,
                                                0, sizeof(t_helloworld),
                                                CLASS_DEFAULT, 0);
        class_addbang(helloworld_class, helloworld_bang);
    }
</code></pre></div></div>

<p>Inizialmente viene definita la nuova <em>classe</em> (qui il termine “classe”
viene usato con un significato diverso da quello usuale della
programmazione ad oggetti), dove <code class="highlighter-rouge">hello_worldclass</code> è un puntatore alla
nuova classe e la struttura <code class="highlighter-rouge">t_helloworld</code> costituisce il <em>dataspace</em>
della classe; la variabile <code class="highlighter-rouge">t_object</code> è assolutamente necessaria e serve
a memorizzare le proprietà dell’oggetto, come la sua rappresentazione
grafica e le informazioni su inlet e outlet.</p>

<p>Vengono poi definite le funzioni (<em>methods</em>) per manipolare i dati;
quando l’istanza della classe riceve un dato, viene richiamato un
metodo; ogni metodo è associato ad un inlet. La funzione implementata
viene eseguita solo quando un nuovo dato arriva a tale inlet.</p>

<p>Al caricamento della libreria, PD richiama la funzione
<code class="highlighter-rouge">helloworld_setup()</code>: tale funzione dichiara la nuova classe e le sue
proprietà. L’istruzione <code class="highlighter-rouge">class_new</code> crea una nuova classe e ritorna un
puntatore ad essa: il primo argomento è il nome simbolico della classe;
il secondo e il terzo definiscono il costruttore e il distruttore; il
quarto definisce la dimensione della struttura dati; il quinto determina
l’aspetto grafico dell’oggetto; i rimanenti sono gli argomenti
dell’oggetto. L’istruzione successiva serve per aggiungere i metodi alla
classe (il primo argomento è la classe, il secondo è il metodo).</p>

<p>L’inizializzazione dell’oggetto avviene tramite la funzione
<code class="highlighter-rouge">helloworld_new()</code>, i cui argomenti dipendono dalla definizione data con
<code class="highlighter-rouge">class_new</code>.</p>

<h3 id="sec:librerie_pd">Librerie utili per Pure Data</h3>

<h4 id="gem">GEM</h4>

<p>GEM (acronimo per <em>Graphical Environment for Multimedia</em>,
<a href="http://gem.iem.at">http://gem.iem.at</a>) è una collezione di external che permettono di
integrare elaborazioni grafiche OpenGL in una patch; sono disponibili
diversi tipi di forme geometriche, di luci e di texture; è possibile
implementare il movimento della visuale e processare l’immagine.</p>

<p>Le elaborazioni della parte audio e della grafica vengono svolte
contemporaneamente: in tal modo si può creare un vero e proprio scenario
virtuale semplicemente utilizzando una rete di blocchi creati e gestiti
come i blocchi nativi di PD.</p>

<h4 id="flext">Flext</h4>

<p>Si è visto che Pure Data è un software scritto in C, e gli external
devono essere scritti in tale linguaggio; l’utente però potrebbe avere
la necessità di usare le meno complesse strutture del C++, nonché il
pieno supporto alla programmazione ad oggetti che questo offre. Per
soddisfare questa esigenza nasce <em>flext</em>
(<a href="http://grrrr.org/ext/flext/">http://grrrr.org/ext/flext/</a>), una libreria per lo sviluppo di
external in C++. Con flext è possibile creare librerie di external che
possono essere compilate per Pure Data, per Max/MSP e per differenti
piattaforme (Windows, Linux, OSX) e compilatori.</p>

<p>Un semplice esempio di external basato su flext è il seguente.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // inclusione del header file
    #include &lt;flext.h&gt;

    // controllo sulla versione
    #if !defined(FLEXT_VERSION) || (FLEXT_VERSION &lt; 400)
    #error You need at least flext version 0.4.0
    #endif

    // definizione della classe
    // Attenzione: il nome della classe deve essere lo stesso
    // nome dell'oggetto (senza l'eventuale ~)
    class simple1:

    public flext_base
    {
        FLEXT_HEADER(simple1,flext_base)

        public:
        // costruttore
        simple1()
        {
            // definizione degli inlets:
            // il primo deve essere sempre di tipo anything
            // (oppure signal per gli oggetti dsp)
            AddInAnything(); 
    
            // definizione degli outlets:
            AddOutFloat(); // aggiunta di un outlet float (indice 0)
    
            // registrazione dei metodi:
            // registra il metodo "m_float" per l'inlet 0
            FLEXT_ADDMETHOD(0,m_float); 
        }
    
        protected:
        // definizione del metodo
        void m_float(float input)
        {
            float result;
            if(input == 0) {
            post("%s - zero can't be inverted!",thisName());
            result = 0;
            }
            else
                result = 1/input;
                
            // manda il valore in output all'outlet
            ToOutFloat(0,result); // (0 è l'indice dell'outlet)
        }

        private:
        // callback per il metodo "m_float"
        FLEXT_CALLBACK_1(m_float,float) 
    };

    // creazione della classe
    FLEXT_NEW("simple1",simple1)
</code></pre></div></div>

<figure class="image">
  <img src="images/flext_bn.jpg" alt="Utilizzo del modulo simple1 basato su flext: accetta un numero in input e invia in output il suo inverso." />
  <figcaption>Utilizzo del modulo simple1 basato su flext: accetta un numero in input e invia in output il suo inverso.</figcaption>
</figure>

<p>Come si può notare, è stata utilizzata la programmazione ad oggetti, a
partire dalla creazione di una classe derivata dalla classe base
<em>flext_base</em>, la quale contiene tutte le funzioni essenziali. Il
costruttore viene richiamato nel momento in cui l’oggetto è incluso
nella patch; più precisamente è chiamato quando si crea un’istanza della
classe, contiene tutte le inizializzazioni necessarie e ha lo stesso
nome della classe. Tra le inizializzazioni devono essere presenti le
dichiarazioni di inlet e outlet e le associazioni tra metodi e
rispettivi inlet.</p>

<p>Un <em>callback wrapper</em> è necessario per stabilire un collegamento con PD
per ogni metodo che deve essere lanciato ogni volta che un dato viene
ricevuto: ciò avviene tramite l’istruzione
<code class="highlighter-rouge">FLEXT_CALLBACK_1(m_float, float)</code>. Con l’ultimo comando si informa il
sistema riguardo al nome della classe e ai suoi argomenti di creazione.</p>

<h3 id="implementazione-della-patch-generatrice-di-rumore-frattale">Implementazione della patch generatrice di rumore frattale</h3>

<p>Nella realizzazione della patch per Pure Data che implementa l’algoritmo
di generazione di rumore frattale, per convenienze implementative, i
filtri sono stati riscritti come cascata di biquadri: perciò la cascata
è formata da <script type="math/tex">N/2</script> filtri del secondo ordine, ognuno con le seguenti
funzioni di trasferimento:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{aligned}
H^{(i)}(z) = H^{j}H^{j-1}(z) & = & \frac{(1+b_jz^{-1})(1+b_{j-1}z^{-1})}{(1+a_jz^{-1})(1+a_{j-1}z^{-1})} \label{eq:surface7} \\
                             & = &\mbox{} \frac{1+(b_j+b_{j-1})z^{-1}+(b_jb_{j-1})z^{-2}}{1+(a_j+a_{j-1})z^{-1}+(a_ja_{j-1})z^{-2}}\\
                                             &   & con~ j=2\cdot i, i=1...N/2.\end{aligned} %]]></script>

<figure class="image">
  <img src="images/surface_modeler1.jpg" alt="La patch surface_modeler che implementa la generazione di rumore frattale." />
  <figcaption>La patch surface_modeler che implementa la generazione di rumore frattale.</figcaption>
</figure>

<p>Il parametro di controllo più importante impostabile dall’utente è
<script type="math/tex">\beta</script>, che definisce lo spettro <script type="math/tex">1/f^{\beta}</script>; deve essere impostato
anche il numero di poli della cascata di filtri assieme alla frequenza
del primo polo: con questi parametri viene controllata l’accuratezza
dell’approssimazione <script type="math/tex">1/f^{\beta}</script>.</p>

<p>Nella figura precedente è riportata la patch <em>surface_modeler</em>
che implementa la generazione di rumore frattale. Per avviare la
computazione è sufficiente cliccare sul blocco (in modalità <em>running</em>):</p>

<figure class="image">
  <img src="images/surfacemodeler2.jpg" alt="" />
  <figcaption></figcaption>
</figure>

<p>subito dopo si seleziona il numero di poli desiderato (due, quattro o
sei). Il controllo sulla patch avviene variando il parametro <script type="math/tex">\beta</script>
tramite lo slider:</p>

<figure class="image">
  <img src="images/surfacemodeler3.jpg" alt="" />
  <figcaption></figcaption>
</figure>

<figure class="image">
  <img src="images/surfacemodeler4.jpg" alt="Il modulo (subpatch) _initialize_fractal_noise" />
  <figcaption>Il modulo (subpatch) _initialize_fractal_noise</figcaption>
</figure>

<p>Il modulo <em>_cascade</em> invece è una subpatch nella quale viene
implementata una cascata di tre filtri; ogni
oggetto <code class="highlighter-rouge">biquad~</code> è un filtro biquadro a due poli e due zeri; ognuno di
questi filtri calcola le seguenti equazioni differenziali:</p>

<script type="math/tex; mode=display">\begin{array}{ll}
y(n) = ff1 \cdot w(n) + ff2 \cdot w(n-1) + ff3 \cdot w(n-2) \\
w(n) = x(n) + fb1 \cdot w(n-1) + fb2 \cdot w(n-2)
\end{array}</script>

<p>I valori <script type="math/tex">fb1, fb2, ff1, ff2, ff3</script> vengono dati, in
quest’ordine, come argomenti di creazione dell’oggetto.</p>

<figure class="image">
  <img src="images/cascade_bn.jpg" alt="La subpatch _cascade" />
  <figcaption>La subpatch _cascade</figcaption>
</figure>

<h3 id="sec:patch_sliding">Implementazione della patch generatrice di rumore di sfregamento</h3>

<figure class="image">
  <img src="images/patchsliding1.jpg" alt="" />
  <figcaption></figcaption>
</figure>

<figure class="image">
  <img src="images/patchsliding2.jpg" alt="" />
  <figcaption></figcaption>
</figure>

<p>Come abbiamo visto è stato sviluppato un modello che descrive il suono
per un corpo che rotola sopra una superficie. Se il corpo, invece di
rotolare, striscia sulla superficie, provoca sempre la generazione di
micro–contatti, che tuttavia avvengono con modalità diverse rispetto al
rotolamento.</p>

<p>Una prima distinzione si ha nella velocità con cui avviene il contatto:
se per il modello di rotolamento deve essere presa in considerazione la
velocità angolare dell’oggetto che rotola (che nel caso di una sfera si
calcola come <script type="math/tex">\omega = v/r</script>, con <script type="math/tex">r</script> raggio della sfera), per un corpo
che striscia si deve considerare la velocità tangenziale, cioè la
velocità lungo il piano sul quale giace la superficie. In secondo luogo
il suono di un moto di rotolamento è spesso caratterizzato da
irregolarità periodiche dovute alle caratteristiche particolari del
corpo che rotola. Se questo non è perfettamente sferico e perfettamente
liscio, i micro–contatti non saranno tutti uguali ma varieranno; in
particolare per un corpo che rotola i micro–contatti si presentano con
le stesse caratteristiche a scadenze periodiche (variabili con la
velocità di movimento), e ciò si riflette nel suono prodotto, il quale
sarà caratterizzato da variazioni periodiche. Per un corpo che striscia
invece le irregolarità della sua superficie non comportano
caratteristiche periodiche nel suono. Tutto ciò è valido se la
dimensione del corpo è sufficientemente grande rispetto alla tessitura
della superficie sulla quale si muove.</p>

<p>La patch che implementa la generazione di rumore di sfregamento è stata quindi elaborata a partire dalla
patch che implementa il modello di rotolamento.</p>

<h4 id="holy-rollersim">holy-roller<script type="math/tex">\sim</script></h4>

<p>Il cuore della computazione viene svolto dalla subpatch <code class="highlighter-rouge">holy_roller~</code>; l’oggetto <code class="highlighter-rouge">holy_roller~</code> possiede 13
inlet:</p>

<ul>
  <li>
    <p>inlet 0 – accetta un oggetto di tipo messaggio contente il nome di un file <code class="highlighter-rouge">.wav</code>; tale file è stato precedentemente ottenuto registrando per circa 10 secondi l’output della patch generatrice di rumore frattale (e pertanto contiene a sua volta un rumore frattale);</p>
  </li>
  <li>
    <p>inlet 1 e 2 – non utilizzati in questa implementazione; accettano entrambi un segnale utilizzato poi come forza aggiuntiva da applicare all’oggetto rotolante;</p>
  </li>
  <li>
    <p>inlet 3 – accetta un numero in virgola mobile proporzionale all’amplificazione in ampiezza che deve subire il rumore frattale;</p>
  </li>
  <li>
    <p>inlet 4 – assumendo che l’oggetto che si muove sulla superficie sia una sfera, questo inlet riceve un numero in virgola mobile corrispondente al diametro della sfera in centimetri; sarà poi utilizzato per calcolarne la massa;</p>
  </li>
  <li>
    <p>inlet 5 – riceve un numero in virgola mobile indicante la velocità (in <script type="math/tex">m/s</script>) dell’oggetto che si muove;</p>
  </li>
  <li>
    <p>inlet 6, 7, 8 e 9 – ricevono tutti dei segnali di controllo per l’impostazione delle frequenze e i tempi di decadimento degli oggetti modali usati nel modello di impatto (il tempo di decadimento è definito come il tempo richiesto affinché l’ampiezza decresca di un fattore <script type="math/tex">1/e</script> rispetto al suo valore iniziale);</p>
  </li>
  <li>
    <p>inlet 10 – riceve un numero in virgola mobile (<script type="math/tex">k</script>) proporzionale alla rigidità dell’oggetto;</p>
  </li>
  <li>
    <p>inlet 11 e 12 – ricevono due numeri in virgola mobile (<script type="math/tex">\alpha</script> e <script type="math/tex">\lambda</script>) utilizzati nel modulo <code class="highlighter-rouge">impact_modalb~</code> per il calcolo della forza di impatto.</p>
  </li>
</ul>

<h4 id="elaborazione-di-diametro-e-velocità">Elaborazione di diametro e velocità</h4>

<p>Il valore del diametro viene elaborato da alcuni blocchi allo scopo di
calcolare dei valori indicanti il volume e la massa dell’oggetto
rotolante.</p>

<p>Il modulo <code class="highlighter-rouge">_smoother</code> ha lo scopo di trasformare una variazione
istantanea del valore del diametro secondo una rampa lineare della
durata di un millisecondo.</p>

<p>Il valore di velocità invece viene inviato in input all’oggetto
<code class="highlighter-rouge">_clip_velo+fade</code>; tale oggetto invia al primo outlet il valore di input
se questo è maggiore del valore dato come primo argomento di costruzione
(che nell’implementazione è <script type="math/tex">0.01</script>), altrimenti viene inviato
quest’ultimo. Il ruolo di questo outlet è impedire che alla patch
successiva <code class="highlighter-rouge">clip_exp~</code> venga inviato costantemente un segnale di
controllo nullo; se ciò si verificasse infatti si creerebbe un ciclo
infinito che porterebbe ad un funzionamento non corretto della patch. Al
secondo outlet viene inviato il valore ricevuto all’inlet opportunamente
scalato nell’intervallo delimitato dai due argomenti.</p>

<h4 id="clip_expsim">clip_exp<script type="math/tex">\sim</script></h4>

<p>I valori di raggio (in metri) e di velocità (in metri al secondo)
vengono inviati ai due oggetti <code class="highlighter-rouge">clip_exp~</code>, la cui funzione è quella di
limitare la variazione logaritmica dei segnali in input. Più
precisamente, in ognuno dei due oggetti viene per prima cosa calcolato
il rapporto tra due campioni in input a distanza di un millisecondo
l’uno dall’altro; se tale rapporto è maggiore di <code class="highlighter-rouge">maxfact</code> o minore di
<code class="highlighter-rouge">minfact</code> (calcolati a partire dal parametro di costruzione), il valore
del campione corrente viene limitato e inviato all’outlet. Se il
rapporto è minore del valore predeterminato, il campione viene inviato
in output invariato. Il codice seguente mostra come questo algoritmo sia
implementato (per ragioni di efficienza) in C.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    static t_int *clip_exp_tilde_perform(t_int *w)
    {
      t_float *in = (t_float *)(w[1]);
      t_float *out = (t_float *)(w[2]);
    
    t_clip_exp_tilde_ctl *c = (t_clip_exp_tilde_ctl *)(w[3]);
    t_int buffersize = (t_int)(w[4]);

    t_float input, ratio;

        // esamina tutto il buffer
    while (buffersize--)
        {
        input = *in++;

            // se last è diverso da zero
        if (c-&gt;last != 0.)
            {
                // se ratio è compreso tra maxfact e minfact
                // in ouput viene mandato input
                // altrimenti l'output è impostato a maxfact o minfact
            ratio = input / c-&gt;last;
        
            if (ratio &gt; c-&gt;maxfact)
                c-&gt;last *= c-&gt;maxfact;
            
            else if (ratio &lt; c-&gt;minfact)
                c-&gt;last *= c-&gt;minfact;
            
            else
                c-&gt;last = input;
            }

      *out++ = c-&gt;last;
    }

    return (w+5);
    }
</code></pre></div></div>

<p>I valori <code class="highlighter-rouge">maxfact</code> e <code class="highlighter-rouge">minfact</code> vengono calcolati nel seguente modo:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    static void set_expmax(t_clip_exp_tilde *x, t_floatarg expmax)
    {
      t_clip_exp_tilde_ctl *c = x-&gt;x_ctl;

        // se l'argomento del modulo è &lt; 1
        // pongo maxfact e minfact = 1
      if (expmax &lt;= 1.)
    {
        c-&gt;maxfact = c-&gt;minfact = 1.;
      post("clip_exp: expmax &lt;= 1?! Is set to 1.");
    }
    // atrimenti:
    // maxfact = epmax^(1000/samprate)
    else
    {
        c-&gt;maxfact = pow(expmax, 1000. / x-&gt;samprate);
      c-&gt;minfact = 1. / c-&gt;maxfact;
    }
    }
</code></pre></div></div>

<h4 id="circ_max_filtersim">circ_max_filter<script type="math/tex">\sim</script></h4>

<p>Gli outlet dei due moduli <code class="highlighter-rouge">clip_exp~</code> sono collegati al secondo e terzo
inlet dell’oggetto <code class="highlighter-rouge">circ_max_filter~</code>:</p>

<p>la sua funzione è quella di tracciare il profilo della superficie sulla
quale l’oggetto rotola e calcolare i punti di contatto tra i due. Nel
primo inlet entra il controllo di segnale ottenuto dalla moltiplicazione
del rumore frattale per il fattore di amplificazione <code class="highlighter-rouge">surface_depth</code>. Il
ciclo principale svolto dal modulo è il seguente:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static t_int *circ_max_filter_perform(t_int *w)
{
    t_float *in1 = (t_float *)(w[1]);
    t_float *in2 = (t_float *)(w[2]);
    t_float *in3 = (t_float *)(w[3]);
    t_float *out = (t_float *)(w[4]);

    t_circ_max_filter_ctl *c = (t_circ_max_filter_ctl *)(w[5]);
    t_float *p_samprate = (t_float *)(w[6]);
    t_int buffersize = (t_int)(w[7]);

    t_float input, radius, velocity;
    t_int range;

    while (buffersize--)
    {
        input = *in1++;
        radius = *in2++;
        velocity = *in3++;

        inc_bottom_ivalue1_circ_buff_1float2int(c-&gt;p_peaks, -1);

        while ((range = bottom_ivalue1_circ_buff_1float2int(c-&gt;p_peaks))
                &lt; bottom_ivalue2_circ_buff_1float2int(c-&gt;p_peaks))
        {
            delete_bottom_circ_buff_1float2int(c-&gt;p_peaks);
            inc_bottom_ivalue1_circ_buff_1float2int(c-&gt;p_peaks, range);
        }
    
        *out++ = up_circle(velocity * range / *p_samprate, radius)
                + bottom_fvalue_circ_buff_1float2int(c-&gt;p_peaks);

        to_buffer(c-&gt;p_peaks, *p_samprate, input, radius, velocity, 1);
    }

    return (w+8);
}
</code></pre></div></div>

<p>In particolare si può notare come l’istruzione</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    *out++ = up_circle(velocity * range / *p_samprate, radius)
            + bottom_fvalue_circ_buff_1float2int(c-&gt;p_peaks);
</code></pre></div></div>

<p>calcola i punti di contatto svolgendo la computazione della funzione <script type="math/tex">f_x(q)</script>.</p>

<p>La funzione <code class="highlighter-rouge">up_circle</code> richiede due argomenti; dopo aver calcolato i
quadrati di questi, ritorna la radice quadrata della differenza dei due:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    static INLINE t_float up_circle(t_float x, t_float radius)
    {
        t_float x_2 = x*x, radius_2 = radius*radius;

        if (x_2 &gt;= radius_2)
        {
          return(0.);
        }
        else
            return(sqrt(radius_2 - x_2));
    }
</code></pre></div></div>

<p>La funzione <code class="highlighter-rouge">to_buffer</code> si occupa di aggiornare il profilo della
superficie in base al segnale ricevuto al primo inlet.</p>

<h4 id="_surface_tracersim">_surface_tracer<script type="math/tex">\sim</script></h4>

<p>Il file con estensione <code class="highlighter-rouge">.wav</code> contenente il rumore frattale viene letto
dalla subpatch <code class="highlighter-rouge">_surface_tracer~</code>. Questa subpatch, assieme alle subpatch
in essa contenute quali <code class="highlighter-rouge">pd tracer+calculation~</code>, <code class="highlighter-rouge">soundfiler_tracer~</code> e
<code class="highlighter-rouge">table_tracer~</code>, legge il file audio e lo scrive in un array;
successivamente, per inviare i campioni in output, esegue una ricerca di
tipo <em>table look–up</em> con frequenza dipendente dalla velocità di
movimento dell’oggetto sulla superficie.</p>

<figure class="image">
  <img src="images/surfacetracer.jpg" alt="" />
  <figcaption></figcaption>
</figure>

<h4 id="impact_modalbsim">impact_modalb<script type="math/tex">\sim</script></h4>

<p>Le successive elaborazioni dei segnali finora calcolati sono svolte dal
modulo <code class="highlighter-rouge">impact_modalb~</code>, un oggetto che implementa il modello descritto
in  <a class="citation" href="#art:soundobj">(Avanzini, F., Rath, M., &amp; Rocchesso, D., 2003)</a> per i suoni di impatto.</p>

<figure class="image">
  <img src="images/impactmodalb.jpg" alt="L'oggetto impact_modalb" />
  <figcaption>L'oggetto impact_modalb</figcaption>
</figure>

<p>In questa implementazione vengono utilizzati due modi e tre punti di
interazione.</p>

<figure class="image">
  <img src="images/partolist.jpg" alt="" />
  <figcaption></figcaption>
</figure>

<p>I parametri della forza di contatto e della massa vengono ricevuti dalla
subpatch <code class="highlighter-rouge">interaction+mass</code> e la subpatch in essa contenuta
<code class="highlighter-rouge">_par_to_list4</code>; in output (secondo outlet) viene mandata
una lista contenente queste informazioni. Nei quattro inlet vengono
ricevuti, in ordine: <script type="math/tex">k</script>, <script type="math/tex">\alpha</script>, <script type="math/tex">\lambda</script> e la massa del percussore.</p>

<p>La subpatch <code class="highlighter-rouge">_modal_object_parameters3_2</code>, dove 3 è il numero di modi e
2 il numero di punti di interazione, raccoglie i parametri del
risonatore. Nei primi tre inlet entrano i fattori moltiplicativi per
frequenza, tempo di decadimento e guadagno; ai successivi tre inlet sono
collegati i controlli delle frequenze di tutti i modi, poi i tempi di
decadimento di tutti i modi. Gli ultimi inlet ricevono i livelli di
ciascun modo per ogni punto di interazione con l’eventuale possibilità
di invertire la fase (<em>phase–reverse</em>). In uscita sono presenti cinque
outlet: il primo per la lista dei fattori, il secondo per la lista delle
frequenze, il terzo per la lista dei tempi di decadimento e un outlet
per ogni punto di interazione con l’indice del punto di interazione
seguito dalla lista dei livelli (con l’eventuale fattore di phase
reverse). Infine l’oggetto <code class="highlighter-rouge">_modal_object_parameters3_2</code> deve essere
inizializzato con la seguente lista di argomenti: lista dei valori delle
frequenze, lista dei valori dei tempi di decadimento, valori dei punti
di interazione e del phase–reverse; un valore 1 per il livello
corrisponde ad una impostazione del relativo slider a 100, dato che
quest’ultimo viene convertito in dB RMS.</p>

<p>L’oggetto <code class="highlighter-rouge">impact_modalb~</code> possiede i seguenti argomenti di costruzione:</p>

<ul>
  <li>
    <p>valori di default di <script type="math/tex">k</script>, <script type="math/tex">\alpha</script>, <script type="math/tex">\lambda</script> e massa del
percussore;</p>
  </li>
  <li>
    <p>numero di modi e numero di punti di interazione;</p>
  </li>
  <li>
    <p>maschera dei punti di interazione;</p>
  </li>
  <li>
    <p>valori di default dei tre fattori di guadagno;</p>
  </li>
  <li>
    <p>valori di default delle frequenze;</p>
  </li>
  <li>
    <p>valori di default dei tempi di decadimento;</p>
  </li>
  <li>
    <p>per ogni punto di interazione il suo indice (partendo da 0) seguito
dai valori dei livelli.</p>
  </li>
</ul>

<figure class="image">
  <img src="images/impactmodalb2.jpg" alt="L'oggetto impact_modalb e la divisione tra i gruppi di argomenti di costruzione" />
  <figcaption>L'oggetto impact_modalb e la divisione tra i gruppi di argomenti di costruzione</figcaption>
</figure>

<h4 id="sec:vandendoel">Dipendenza dell’ampiezza del suono dalla forza normale</h4>

<p>Secondo studi svolti da Van Den Doel, Kry e Pai [@art:vandendoel], nei
contatti che avvengono tra due corpi e che coinvolgono forze di
frizione, queste ultime sono calcolabili come:
<script type="math/tex">F_{frizione} = \mu F_{normale}</script> e il volume del suono prodotto da
ogni contatto è proporzionale a <script type="math/tex">\sqrt{v \cdot F_{normale}}</script>, dove <script type="math/tex">v</script> è
la velocità alla quale avviene il contatto; in questo calcolo si assume
che l’energia acustica sia proporzionale alla perdita di capacità da
parte della superficie di opporre una resistenza (di frizione) al moto.
Nella subpatch <code class="highlighter-rouge">holy_roller~</code> tale caratteristica è implementata tramite
gli oggetti in figura:</p>

<figure class="image">
  <img src="images/vandendoel.jpg" alt="" />
  <figcaption></figcaption>
</figure>

<h2 id="riferimenti">Riferimenti</h2>

<ol class="bibliography"><li><span id="art:soundobj">Avanzini, F., Rath, M., &amp; Rocchesso, D. (2003). Low-level sound models: resonators, interactions, surface textures. <i>The Sounding Object</i>, 119–148.</span></li>
<li><span id="book:fractal">Hastings, H. M., &amp; Sugihara, G. (1993). <i>Fractals: A User’s Guide for the Natural Sciences.</i> Oxford University Press.</span></li>
<li><span id="book:brownian">Resnick, S. (1992). <i>Adventures in Stochastic Processes</i>. Birkhäuser Boston.</span></li>
<li><span id="book:wornell">Wornell, G. W. (1998). <i>The Digital Signal Processing Handbook</i>. CRC Press and IEEE Press.</span></li>
<li><span id="art:pentland">Pentland, A. P. (1988). Fractal-Based Description Of Surfaces. <i>Natural Computation</i>, 279–298.</span></li>
<li><span id="art:saletti">Saletti, R. (Novembre 1986). A comparison between two methods to generate 1/f^γnoise. <i>Proc. IEEE</i>, <i>74</i>, 1595–1596.</span></li>
<li><span id="art:corsini">Corsini, G., &amp; Saletti, R. (Dicembre 1988). A 1/f^γpower spectrum noise sequence generator. <i>IEEE Trans. on Instrumentation and Measurement</i>, <i>37</i>(4), 615–619.</span></li>
<li><span id="book:mitra">Mitra, S. K. (1998). <i>Digital Signal Processing: A Computer Based Approach</i>. McGraw-Hill.</span></li>
<li><span id="pdexternal">Zmölnig, J. M. <i>HOWTO write an external for puredata</i>. Institut for electronic music and acoustics.</span></li></ol>


<span class="post-date">
  Pubblicato il
  
  January
  29th,
  2019
  by
  
    Andrea Maglie
  
</span>

<div class="post-date">Condividi!</div>
  <div class="sharing-icons">
    <a href="https://twitter.com/intent/tweet?text=Pure Data e i modelli audio&amp;url=/pure-data-modelli-audio.html" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
    <a href="https://www.facebook.com/sharer/sharer.php?u=/pure-data-modelli-audio.html&amp;title=Pure Data e i modelli audio" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a>
    <a href="https://plus.google.com/share?url=/pure-data-modelli-audio.html" target="_blank"><i class="fa fa-google-plus" aria-hidden="true"></i></a>
  </div>
</div>


<div class="related">
  <h1 >Potrebbero interessarti:</h1>
  
  <ul class="related-posts">
    
      
        
          <li>
            <h3>
              <a href="/esperimenti-percezione-audio-aptica.html">
                Esperimenti sulla percezione audio--aptica
                <!--<img src="/images/">-->
                <!--<small>February 26, 2019</small>-->
              </a>
            </h3>
          </li>
          
        
      
        
          <li>
            <h3>
              <a href="/applicazione-phantom-friction.html">
                L'applicazione Phantom Friction
                <!--<img src="/images/">-->
                <!--<small>February 19, 2019</small>-->
              </a>
            </h3>
          </li>
          
        
      
        
          <li>
            <h3>
              <a href="/phantom-omni.html">
                Il Phantom  Omni
                <!--<img src="/images/">-->
                <!--<small>February 12, 2019</small>-->
              </a>
            </h3>
          </li>
          
        
      
    
      
        
        
      
        
        
      
        
        
      
    
  </ul>
</div>



  <section class="disqus">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname = "techisfun";
    var disqus_identifier = "/pure-data-modelli-audio.html";
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>



    </div>

    <footer class="footer">
  
  
  
    <a href="https://www.github.com/techisfun" target="_blank"><i class="fa fa-github" aria-hidden="true"></i></a>
  

  
  
    <a href="https://twitter.com/techisfun" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
  

  
  
    <a href="http://www.linkedin.com/in/andreamaglie/" target="_blank"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
  

  
  
    <a href="mailto:l.andrea.maglie@gmail.com" target="_blank"><i class="fa fa-envelope" aria-hidden="true"></i></a>
  

  
  
    <a href="/feed.xml"><i class="fa fa-rss-square" aria-hidden="true"></i></a>
  

  <div class="post-date"><a href="/menu/about.html">ing. Andrea Maglie |  by Andrea Maglie</a></div>
</footer>

  </div>

</body>
</html>
